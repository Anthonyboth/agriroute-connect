// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

// Supabase publishable credentials - safe for client-side use, protected by RLS
const SUPABASE_URL = "https://shnvtxejjecbnztdbbbl.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNobnZ0eGVqamVjYm56dGRiYmJsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNjAzMzAsImV4cCI6MjA3MjkzNjMzMH0.qcYO3vsj8KOmGDGM12ftFpr0mTQP5DB_0jAiRkPYyFg";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Check if we're on a public page that doesn't need realtime
const isPublicPage = typeof window !== 'undefined' && 
  ['/', '/auth', '/about', '/privacy', '/terms', '/cookies', '/plans', '/services', '/help', '/careers', '/status'].some(
    path => window.location.pathname === path || window.location.pathname.startsWith('/auth')
  );

// Create client with realtime disabled on public pages to prevent WebSocket errors
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage, // Usar localStorage para manter sessão persistente
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
  },
  realtime: isPublicPage ? {
    // Completely disable realtime on public pages
    params: {
      eventsPerSecond: 0
    }
  } : {
    params: {
      eventsPerSecond: 10
    },
    timeout: 30000,
    heartbeatIntervalMs: 30000
  },
  global: {
    headers: {
      'X-Client-Info': 'agriroute-web'
    }
  }
});

// Completely disable realtime on public pages to prevent WebSocket console errors
if (isPublicPage && typeof window !== 'undefined') {
  // Disconnect realtime to prevent WebSocket connection attempts
  supabase.realtime.disconnect();
}

/**
 * Sanitize error data to remove sensitive information in production
 */
function sanitizeErrorData(data: Record<string, any>): Record<string, any> {
  // In development, return full data
  if (import.meta.env.DEV) {
    return data;
  }
  
  // In production, sanitize sensitive fields
  const sanitized = { ...data };
  
  // Remove stack traces in production
  if (sanitized.errorStack) {
    sanitized.errorStack = '[REDACTED IN PRODUCTION]';
  }
  
  // Sanitize URL to remove query parameters
  if (sanitized.metadata?.url) {
    try {
      const url = new URL(sanitized.metadata.url);
      sanitized.metadata.url = `${url.origin}${url.pathname}`;
    } catch {
      sanitized.metadata.url = '[REDACTED]';
    }
  }
  
  // Remove internal file paths
  if (sanitized.metadata?.filename) {
    sanitized.metadata.filename = '[REDACTED]';
  }
  
  // Simplify user agent
  if (sanitized.metadata?.userAgent) {
    sanitized.metadata.userAgent = '[BROWSER]';
  }
  
  return sanitized;
}

/**
 * Função para notificar erros no Telegram
 * Chamada para TODOS os erros, sem exceções
 */
async function notifyErrorToTelegram(errorData: {
  errorType: string;
  errorCategory: string;
  errorMessage: string;
  errorStack?: string;
  module?: string;
  route?: string;
  metadata?: Record<string, any>;
}) {
  try {
    // Sanitize data before sending
    const sanitizedData = sanitizeErrorData(errorData);
    
    await fetch(`${SUPABASE_URL}/functions/v1/telegram-error-notifier`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        'X-Skip-Error-Monitoring': 'true'
      },
      body: JSON.stringify(sanitizedData)
    });
  } catch (e) {
    // Fail silently - não queremos loops infinitos de erro
  }
}

// Capturar e NOTIFICAR erros (não suprimir)
// Defer error monitoring setup to not block TTI on initial load
if (typeof window !== 'undefined' && !isPublicPage) {
  const isWebSocketError = (message: string) => {
    return (message.includes('WebSocket') || message.includes('websocket')) &&
           (message.includes('ERR_NAME_NOT_RESOLVED') || 
            message.includes('failed') || 
            message.includes('connection'));
  };

  // Throttle para evitar spam de notificações (máx 1 por minuto para mesmo tipo de erro)
  const notificationThrottle = new Map<string, number>();
  const THROTTLE_MS = 60000; // 1 minuto

  const shouldNotify = (errorKey: string): boolean => {
    const lastNotified = notificationThrottle.get(errorKey);
    const now = Date.now();
    if (!lastNotified || (now - lastNotified) > THROTTLE_MS) {
      notificationThrottle.set(errorKey, now);
      return true;
    }
    return false;
  };

  const originalConsoleError = console.error;
  console.error = (...args: any[]) => {
    const message = args[0]?.toString() || '';
    
    // Sempre logar no console
    originalConsoleError.apply(console, args);
    
    // Notificar erros de WebSocket no Telegram
    if (isWebSocketError(message) && shouldNotify('websocket_error')) {
      notifyErrorToTelegram({
        errorType: 'WEBSOCKET',
        errorCategory: 'SIMPLE',
        errorMessage: message.substring(0, 500),
        module: 'supabase-client',
        route: window.location.pathname,
        metadata: {
          userAgent: navigator.userAgent,
          url: window.location.href,
          timestamp: new Date().toISOString()
        }
      });
    }
  };

  // Capturar console.warn também
  const originalConsoleWarn = console.warn;
  console.warn = (...args: any[]) => {
    const message = args[0]?.toString() || '';
    originalConsoleWarn.apply(console, args);
    
    if (isWebSocketError(message) && shouldNotify('websocket_warn')) {
      notifyErrorToTelegram({
        errorType: 'WEBSOCKET',
        errorCategory: 'SIMPLE',
        errorMessage: `[WARN] ${message.substring(0, 500)}`,
        module: 'supabase-client',
        route: window.location.pathname,
        metadata: {
          userAgent: navigator.userAgent,
          url: window.location.href,
          timestamp: new Date().toISOString()
        }
      });
    }
  };

  // Capturar erros não tratados no window
  window.addEventListener('error', (event) => {
    const message = event.message || '';
    const errorKey = `window_error_${message.substring(0, 50)}`;
    
    if (shouldNotify(errorKey)) {
      notifyErrorToTelegram({
        errorType: 'FRONTEND',
        errorCategory: 'CRITICAL',
        errorMessage: message.substring(0, 500),
        errorStack: event.error?.stack,
        module: 'window-error-handler',
        route: window.location.pathname,
        metadata: {
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno,
          userAgent: navigator.userAgent,
          url: window.location.href,
          timestamp: new Date().toISOString()
        }
      });
    }
  });

  // Capturar promise rejections não tratadas
  window.addEventListener('unhandledrejection', (event) => {
    const message = event.reason?.message || String(event.reason);
    const errorKey = `promise_rejection_${message.substring(0, 50)}`;
    
    if (shouldNotify(errorKey)) {
      notifyErrorToTelegram({
        errorType: 'FRONTEND',
        errorCategory: 'CRITICAL',
        errorMessage: `Unhandled Promise Rejection: ${message.substring(0, 400)}`,
        errorStack: event.reason?.stack,
        module: 'unhandled-rejection-handler',
        route: window.location.pathname,
        metadata: {
          userAgent: navigator.userAgent,
          url: window.location.href,
          timestamp: new Date().toISOString()
        }
      });
    }
  });
}

// Make supabase client available globally for retry logic
(window as any).__supabaseClient = supabase;
