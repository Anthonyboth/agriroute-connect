// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

// Supabase publishable credentials - safe for client-side use, protected by RLS
const SUPABASE_URL = "https://shnvtxejjecbnztdbbbl.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNobnZ0eGVqamVjYm56dGRiYmJsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNjAzMzAsImV4cCI6MjA3MjkzNjMzMH0.qcYO3vsj8KOmGDGM12ftFpr0mTQP5DB_0jAiRkPYyFg";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Check if we're on a public page that doesn't need realtime
const isPublicPage = typeof window !== 'undefined' && 
  ['/', '/auth', '/sobre', '/privacy', '/privacidade', '/terms', '/termos', '/cookies', '/plans', '/services', '/help', '/ajuda', '/careers', '/carreiras', '/status'].some(
    path => window.location.pathname === path || window.location.pathname.startsWith('/auth')
  );

// Realtime configuration - completely disabled on public pages to prevent WebSocket errors
const realtimeConfig = isPublicPage ? {
  // On public pages, use a dummy URL that prevents connection attempts
  // This prevents ERR_NAME_NOT_RESOLVED errors in Lighthouse
  transport: undefined as any, // Disable transport entirely
  params: {
    eventsPerSecond: 0
  },
  // Set to never connect
  autoConnect: false,
  // Prevent automatic connection by using extremely long timeouts
  timeout: 0,
  heartbeatIntervalMs: Number.MAX_SAFE_INTEGER,
  // Disable reconnect attempts completely
  reconnectAfterMs: () => Number.MAX_SAFE_INTEGER,
  // Disable logging
  log_level: 'silent' as any
} : {
  params: {
    eventsPerSecond: 10
  },
  timeout: 30000,
  heartbeatIntervalMs: 30000
};

// Create Supabase client with realtime configuration
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: typeof window !== 'undefined' ? localStorage : undefined,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
  },
  realtime: realtimeConfig,
  global: {
    headers: {
      'X-Client-Info': 'agriroute-web'
    }
  }
});

// Immediately disconnect realtime on public pages BEFORE any connection attempt
if (isPublicPage && typeof window !== 'undefined') {
  // Synchronously disconnect to prevent any WebSocket connection attempts
  try {
    // Disconnect immediately - not in microtask to prevent race condition
    supabase.realtime.setAuth(null);
    supabase.removeAllChannels();
    supabase.realtime.disconnect();
    
    // Override connect method to prevent any future connection attempts on public pages
    const originalConnect = supabase.realtime.connect.bind(supabase.realtime);
    supabase.realtime.connect = () => {
      // No-op on public pages - prevent WebSocket connection
      return Promise.resolve();
    };
  } catch {
    // Silently handle any disconnection errors
  }
}

/**
 * Check if a message contains SQL-like syntax that could reveal database structure
 */
function containsSqlSyntax(message: string): boolean {
  const sqlPatterns = [
    /\b(SELECT|INSERT|UPDATE|DELETE|FROM|WHERE|JOIN|CREATE|ALTER|DROP|TABLE|COLUMN|INDEX)\b/i,
    /\b(pg_|information_schema|public\.)\w+/i,
    /\b(uuid|jsonb?|text|integer|boolean|timestamp)\b/i,
    /\bviolates\s+(foreign|unique|check)\s+key/i,
    /\brow-level\s+security/i,
    /\bpolicy\b.*\b(for|on|using|with\s+check)\b/i
  ];
  return sqlPatterns.some(pattern => pattern.test(message));
}

/**
 * Whitelist of allowed error categories
 * SECURITY: Only these categories are sent to external monitoring
 */
const ALLOWED_ERROR_CATEGORIES = new Set([
  'WEBSOCKET',
  'NETWORK',
  'AUTH',
  'VALIDATION',
  'UNKNOWN'
]);

/**
 * Sanitize error data to remove sensitive information
 * SECURITY: Always sanitize in ALL environments to prevent data leakage
 */
function sanitizeErrorData(data: Record<string, any>): Record<string, any> {
  // Validate error category against whitelist
  const errorCategory = ALLOWED_ERROR_CATEGORIES.has(data.errorCategory) 
    ? data.errorCategory 
    : 'UNKNOWN';
  
  // Always sanitize - never send full data even in development
  const sanitized: Record<string, any> = {
    errorType: data.errorType,
    errorCategory,
    module: data.module,
    route: data.route,
    metadata: {
      timestamp: data.metadata?.timestamp || new Date().toISOString()
    }
  };
  
  // Sanitize error message - remove sensitive patterns
  if (data.errorMessage) {
    let message = data.errorMessage
      // Remove UUIDs
      .replace(/\b[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\b/gi, '[UUID]')
      // Remove emails
      .replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, '[EMAIL]')
      // Remove JWT tokens
      .replace(/eyJ[A-Za-z0-9_-]+\.eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g, '[JWT]')
      // Remove API keys patterns
      .replace(/\b(sk_|pk_|api_|key_)[a-zA-Z0-9]{20,}\b/g, '[API_KEY]')
      // Remove phone numbers (Brazilian format)
      .replace(/\b(\+55\s?)?\(?\d{2}\)?\s?\d{4,5}[-.\s]?\d{4}\b/g, '[PHONE]')
      // Remove CPF/CNPJ
      .replace(/\b\d{3}\.?\d{3}\.?\d{3}[-.]?\d{2}\b/g, '[CPF]')
      .replace(/\b\d{2}\.?\d{3}\.?\d{3}\/?\d{4}[-.]?\d{2}\b/g, '[CNPJ]')
      // Limit length
      .substring(0, 200);
    
    // SECURITY: If message contains SQL syntax, replace with generic message
    if (containsSqlSyntax(message)) {
      message = '[DATABASE_ERROR]';
    }
    
    sanitized.errorMessage = message;
  }
  
  // Never include stack traces - they reveal internal structure
  // errorStack is intentionally omitted
  
  // Sanitize URL - only keep origin and pathname without query params
  if (data.metadata?.url) {
    try {
      const url = new URL(data.metadata.url);
      sanitized.metadata.url = `${url.origin}${url.pathname}`;
    } catch {
      sanitized.metadata.url = '[INVALID_URL]';
    }
  }
  
  // Remove all internal paths and user agents
  // filename, lineno, colno, userAgent are intentionally omitted
  
  return sanitized;
}

/**
 * Função para notificar erros no Telegram
 * Chamada para TODOS os erros, sem exceções
 */
async function notifyErrorToTelegram(errorData: {
  errorType: string;
  errorCategory: string;
  errorMessage: string;
  errorStack?: string;
  module?: string;
  route?: string;
  metadata?: Record<string, any>;
}) {
  try {
    // Sanitize data before sending
    const sanitizedData = sanitizeErrorData(errorData);
    
    await fetch(`${SUPABASE_URL}/functions/v1/telegram-error-notifier`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        'X-Skip-Error-Monitoring': 'true'
      },
      body: JSON.stringify(sanitizedData)
    });
  } catch (e) {
    // Fail silently - não queremos loops infinitos de erro
  }
}

// Helper function to sanitize a single argument for production console output
function sanitizeConsoleArg(arg: any): any {
  if (typeof arg === 'string') {
    return arg
      .replace(/\b[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\b/gi, '[UUID]')
      .replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, '[EMAIL]')
      .replace(/eyJ[A-Za-z0-9_-]+\.eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g, '[JWT]')
      .replace(/\b(sk_|pk_|api_|key_)[a-zA-Z0-9]{20,}\b/g, '[API_KEY]')
      .replace(/\b\d{3}\.?\d{3}\.?\d{3}[-.]?\d{2}\b/g, '[CPF]')
      .replace(/\b\d{2}\.?\d{3}\.?\d{3}\/?\d{4}[-.]?\d{2}\b/g, '[CNPJ]')
      .replace(/\b(\+55\s?)?\(?\d{2}\)?\s?\d{4,5}[-.\s]?\d{4}\b/g, '[PHONE]')
      .substring(0, 500);
  }
  if (typeof arg === 'object' && arg !== null) {
    try {
      const str = JSON.stringify(arg);
      const sanitized = sanitizeConsoleArg(str);
      return JSON.parse(sanitized);
    } catch {
      return '[OBJECT]';
    }
  }
  return arg;
}

// Capturar e NOTIFICAR erros (não suprimir)
// Defer error monitoring setup to not block TTI on initial load
if (typeof window !== 'undefined' && !isPublicPage) {
  // SECURITY: Sanitize console.log in production to prevent PII leakage in DevTools
  if (import.meta.env.PROD) {
    const originalConsoleLog = console.log;
    console.log = (...args: any[]) => {
      const sanitizedArgs = args.map(sanitizeConsoleArg);
      originalConsoleLog.apply(console, sanitizedArgs);
    };
  }
  const isWebSocketError = (message: string) => {
    return (message.includes('WebSocket') || message.includes('websocket')) &&
           (message.includes('ERR_NAME_NOT_RESOLVED') || 
            message.includes('failed') || 
            message.includes('connection'));
  };

  // Throttle para evitar spam de notificações (máx 1 por minuto para mesmo tipo de erro)
  const notificationThrottle = new Map<string, number>();
  const THROTTLE_MS = 60000; // 1 minuto

  const shouldNotify = (errorKey: string): boolean => {
    const lastNotified = notificationThrottle.get(errorKey);
    const now = Date.now();
    if (!lastNotified || (now - lastNotified) > THROTTLE_MS) {
      notificationThrottle.set(errorKey, now);
      return true;
    }
    return false;
  };

  const originalConsoleError = console.error;
  console.error = (...args: any[]) => {
    const message = args[0]?.toString() || '';
    
    // SECURITY: In production, sanitize console output to prevent sensitive data exposure
    if (import.meta.env.PROD) {
      const sanitizedArgs = args.map(sanitizeConsoleArg);
      originalConsoleError.apply(console, sanitizedArgs);
    } else {
      // Development: full logging for debugging
      originalConsoleError.apply(console, args);
    }
    
    // Notificar erros de WebSocket no Telegram
    if (isWebSocketError(message) && shouldNotify('websocket_error')) {
      notifyErrorToTelegram({
        errorType: 'WEBSOCKET',
        errorCategory: 'SIMPLE',
        errorMessage: message.substring(0, 500),
        module: 'supabase-client',
        route: window.location.pathname,
        metadata: {
          url: window.location.href,
          timestamp: new Date().toISOString()
        }
      });
    }
  };

  // Capturar console.warn também
  const originalConsoleWarn = console.warn;
  console.warn = (...args: any[]) => {
    const message = args[0]?.toString() || '';
    
    // SECURITY: In production, sanitize console output
    if (import.meta.env.PROD) {
      const sanitizedArgs = args.map(sanitizeConsoleArg);
      originalConsoleWarn.apply(console, sanitizedArgs);
    } else {
      originalConsoleWarn.apply(console, args);
    }
    
    if (isWebSocketError(message) && shouldNotify('websocket_warn')) {
      notifyErrorToTelegram({
        errorType: 'WEBSOCKET',
        errorCategory: 'SIMPLE',
        errorMessage: `[WARN] ${message.substring(0, 500)}`,
        module: 'supabase-client',
        route: window.location.pathname,
        metadata: {
          url: window.location.href,
          timestamp: new Date().toISOString()
        }
      });
    }
  };

  // Capturar erros não tratados no window
  window.addEventListener('error', (event) => {
    const message = event.message || '';

    // ✅ Não notificar conflitos esperados de regra de negócio (ex.: CPF/CNPJ já cadastrado)
    // Isso evita alertas de "blank screen" quando o backend retorna 409 intencionalmente.
    const isExpectedFiscalIssuerConflict =
      message.includes('Edge function returned 409') &&
      (message.includes('fiscal-issuer-register') ||
        message.includes('Este CPF/CNPJ já está cadastrado'));

    if (isExpectedFiscalIssuerConflict) {
      return;
    }

    const errorKey = `window_error_${message.substring(0, 50)}`;

    if (shouldNotify(errorKey)) {
      // SECURITY: Only send minimal, non-sensitive error info
      notifyErrorToTelegram({
        errorType: 'FRONTEND',
        errorCategory: 'CRITICAL',
        errorMessage: message.substring(0, 200),
        // SECURITY: Never send stack traces - they expose internal structure
        module: 'window-error-handler',
        route: window.location.pathname,
        metadata: {
          // SECURITY: Omit filename, lineno, colno, userAgent - they reveal internal info
          url: window.location.href,
          timestamp: new Date().toISOString()
        }
      });
    }
  });

  // Capturar promise rejections não tratadas
  window.addEventListener('unhandledrejection', (event) => {
    const message = event.reason?.message || String(event.reason);

    // ✅ Não notificar conflitos esperados de regra de negócio (ex.: CPF/CNPJ já cadastrado)
    const isExpectedFiscalIssuerConflict =
      message.includes('Edge function returned 409') &&
      (message.includes('fiscal-issuer-register') ||
        message.includes('Este CPF/CNPJ já está cadastrado'));

    if (isExpectedFiscalIssuerConflict) {
      // Evita "CRITICAL" e "blank screen" nos alertas
      event.preventDefault?.();
      return;
    }

    const errorKey = `promise_rejection_${message.substring(0, 50)}`;

    if (shouldNotify(errorKey)) {
      // SECURITY: Only send minimal, non-sensitive error info
      notifyErrorToTelegram({
        errorType: 'FRONTEND',
        errorCategory: 'CRITICAL',
        errorMessage: `Unhandled Promise Rejection: ${message.substring(0, 200)}`,
        // SECURITY: Never send stack traces
        module: 'unhandled-rejection-handler',
        route: window.location.pathname,
        metadata: {
          // SECURITY: Omit userAgent - reveals client info
          url: window.location.href,
          timestamp: new Date().toISOString()
        }
      });
    }
  });
}

// Make supabase client available globally for retry logic
(window as any).__supabaseClient = supabase;
